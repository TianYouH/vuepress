(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{386:function(a,t,s){"use strict";s.r(t);var r=s(42),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),s("h2",{attrs:{id:"列举你所了解的计算机存储设备类型？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列举你所了解的计算机存储设备类型？"}},[a._v("#")]),a._v(" 列举你所了解的计算机存储设备类型？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("用来存储信息的设备称为计算机的存储设备，如内存、硬盘、软盘和光盘。\n内存是直接与CPU相联系的存储设备，运算速度快，价格高。\n硬盘是微机主要的存储设备，它的特点是存储容量大，读写速度快可靠性高，使用方便。\n")])])]),s("h2",{attrs:{id:"一般代码存储在计算机的哪个设备中？代码在-cpu-中是如何运行的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一般代码存储在计算机的哪个设备中？代码在-cpu-中是如何运行的？"}},[a._v("#")]),a._v(" 一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("我们写的程序是放在硬盘中的，\n在运行的时候才会被调入到内存中，就是说内存中的数据是从硬盘来的，\n而CPU中寄存器的数据又是从内存中装载进来的，然后CPU会根据相应的指令去操作寄存器中的数据，比如四则运算什么的，来完成一个程序在计算机中的运行。\n一句话总结：本身程序是在硬盘上，需要把程序加载进内存，然后由CPU去执行​​​​​​​。\n")])])]),s("h2",{attrs:{id:"什么是指令和指令集？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是指令和指令集？"}},[a._v("#")]),a._v(" 什么是指令和指令集？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。\n指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。指令的强弱也是CPU的重要指标，指令集是提高微处理器效率的最有效的工具之一。从现阶段的主流体系结构讲，指令集可分为复杂指令集和精简指令集两部分\n")])])]),s("h2",{attrs:{id:"复杂指令集和精简指令集有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复杂指令集和精简指令集有什么区别？"}},[a._v("#")]),a._v(" 复杂指令集和精简指令集有什么区别？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("CISC(复杂指令集计算机)和RISC(精简指令集计算机)\n\n从硬件角度来看\nCISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。\nRISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。\n因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。\n\n从软件角度来看\nCISC运行的则是我们所熟识的DOS、Windows操作系统。而且它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，象赫赫有名的Microsoft就是其中的一家。\nRISC在此方面却显得有些势单力薄。虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。\n目前CISC与RISC正在逐步走向融合，Pentium Pro、Nx586、K5就是一个最明显的例子，它们的内核都是基于RISC体系结构的。他们接受CISC指令后将其分解分类成RISC指令以便在遇一时间内能够执行多条指令。由此可见，下一代的CPU将融合CISC与RISC两种技术，从软件与硬件方面看二者会取长补短\n")])])]),s("h2",{attrs:{id:"javascript-是如何运行的？解释型语言和编译型语言的差异是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-是如何运行的？解释型语言和编译型语言的差异是什么？"}},[a._v("#")]),a._v(" JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("JS引擎： 也称为javascript解释器，用来读取网页中的javascript代码，对其处理后运行，\n比如chrome浏览器的V8,浏览器并不会执行javascript代码，而是通过内置的js引擎(解释器)来执行javascript代码\njavascript引擎执行代码时逐行解释每一句源码(转换为机器语言)，然后由计算机去执行，所以javascript语言归为脚本语言，会逐行解释执行\n\nJavaScript解析过程分为两个阶段，一个是编译阶段，另外一个就是执行阶段。\n  编译阶段就是我们常说的JavaScript预解析（预处理）阶段，在这个阶段JavaScript解释器将完成把JavaScript脚本代码转换到字节码。\n  在编译阶段JavaScript解释器借助执行环境把字节码生成机械码，并顺序执行。\n\n编译型与解释型的差异是什么:\n区别就在于“转化的方式”不一样\n1.从运行效果上来看：编译型语言要等全部写完后通过编译器去生成一个类似*.exe的二进制文件，然后双击这个文件才可以看到效果。而解释型语言并没生成*.exe文件，而是直接生成效果，这就是我之前提到的的那个C语言和MATLAB的例子。\n\n2.运行的时候是否需要编译器（或解释器）的伴随：编译型语言运行的是最终生成的二进制代码，所以不需要编译器伴随。而解释型语言则一边解释一边运行，所以运行的时候很可能还有部分代码没有解释好，所以需要解释器伴随。有人会问编译器（解释器）在哪里呢？举个例子，网页的解释器就在浏览器中，所以要看HTML的效果必须用浏览器或者有编译工具在内的其他工具打开，比如：模拟浏览器的工具。\n\n3.执行的速度对比：编译型语言运行的已经是完全的二进制内容，运行起来十分干净利落，所以速度很快。而解释型语言运行的不一定是完全的二进制内容，因为它是一边解释成二进制一边运行。所以当它执行看出效果的时，程序后半部分还不一定解释成二进制，速度没有前者快，但是CPU的运行速度如果很快，可能看不出来，只是偶尔会看到“有点卡”的效果。原因就是它一边解释一边运行，你看到效果的后面可能还有一少半的代码没解释成二进制，所以看到的效果会是残缺的。这就是为什么有时候查看网页，先是出现一堆没有布局的文字，然后才出现那种布局好的效果。\n\n4.可移植性对比：编译型语言是运行二进制内容，所以一旦CPU指令系统改变，那么之前的二进制文件可能运行不了。比如，如果到其他硬件平台上运行，就可能出现错误，就需要根据该平台重新编译出新的二进制文件。所以可移植性、平台兼容性比价差。而解释型语言则没有弄成什么二进制内容，而是在需要的时候才开始编译、运行。所以它自然具有可移植性，即在任何平台都可以马上运行起来。要注意的是它的解释工具如：浏览器，本身就是编译型语言解释出来的二进制代码，所以浏览器本身不具备可移植性，是需要针对不同的平台弄出对应的浏览器最终二进制文件的，这里可别混淆。\n\n5.升级上对比：编译型语言弄出来的二进制文件若要升级，自然要重新下载一个新的二进制文件。所以重新下载、安装、覆盖是最大的特点。比如微信的升级，就是要重新下载、重新安装、重新覆盖，等个半天而且很耗费CPU资源，体验性就不大好。而解释型的语言只要重新写好源代码即可，用户想要最新的效果，只要刷新一下即可，所以体验性好。比如：某网站平台升级了，用户只要重新刷新一下。\n\n6.应用领域，编译型语言应用领域通常是那些安装软件，例如桌面上的安装软件。解释型的语言的应用领域通常是互联网、网站等那种刷新了一下就可以看到最新效果的领域。\n")])])]),s("h2",{attrs:{id:"描述-babel-的编译过程？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述-babel-的编译过程？"}},[a._v("#")]),a._v(" 描述 Babel 的编译过程？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("解析（Parsing）：将代码字符串解析成抽象语法树。\n转换（Transformation）：对抽象语法树进行转换操作。\n生成（Code Generation）: 根据变换后的抽象语法树再生成代码字符串。\n")])])]),s("p",[s("img",{attrs:{src:"/blogs/image/web/issue/%E7%A4%BA%E4%BE%8B-1.png",alt:"示例-1"}})]),a._v(" "),s("h2",{attrs:{id:"javascript-中的数组和函数在内存中是如何存储的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的数组和函数在内存中是如何存储的？"}},[a._v("#")]),a._v(" JavaScript 中的数组和函数在内存中是如何存储的？")]),a._v(" "),s("h2",{attrs:{id:"浏览器和-node-js-中的事件循环机制有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器和-node-js-中的事件循环机制有什么区别？"}},[a._v("#")]),a._v(" 浏览器和 Node.js 中的事件循环机制有什么区别？")]),a._v(" "),s("h2",{attrs:{id:"es6-modules-相对于-commonjs-的优势是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-modules-相对于-commonjs-的优势是什么？"}},[a._v("#")]),a._v(" ES6 Modules 相对于 CommonJS 的优势是什么？")]),a._v(" "),s("h2",{attrs:{id:"高级程序设计语言是如何编译成机器语言的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高级程序设计语言是如何编译成机器语言的？"}},[a._v("#")]),a._v(" 高级程序设计语言是如何编译成机器语言的？")]),a._v(" "),s("h2",{attrs:{id:"编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？"}},[a._v("#")]),a._v(" 编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？")]),a._v(" "),s("h2",{attrs:{id:"编译过程中虚拟机的作用是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译过程中虚拟机的作用是什么？"}},[a._v("#")]),a._v(" 编译过程中虚拟机的作用是什么？")]),a._v(" "),s("h2",{attrs:{id:"什么是中间代码（ir），它的作用是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是中间代码（ir），它的作用是什么？"}},[a._v("#")]),a._v(" 什么是中间代码（IR），它的作用是什么？")]),a._v(" "),s("h2",{attrs:{id:"什么是交叉编译？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是交叉编译？"}},[a._v("#")]),a._v(" 什么是交叉编译？")]),a._v(" "),s("h2",{attrs:{id:"发布-订阅模式和观察者模式的区别是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式和观察者模式的区别是什么？"}},[a._v("#")]),a._v(" 发布 / 订阅模式和观察者模式的区别是什么？")]),a._v(" "),s("h2",{attrs:{id:"装饰器模式一般会在什么场合使用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式一般会在什么场合使用？"}},[a._v("#")]),a._v(" 装饰器模式一般会在什么场合使用？")]),a._v(" "),s("h2",{attrs:{id:"谈谈你对大型项目的代码解耦设计理解？什么是-ioc？一般-di-采用什么设计模式实现？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对大型项目的代码解耦设计理解？什么是-ioc？一般-di-采用什么设计模式实现？"}},[a._v("#")]),a._v(" 谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？")]),a._v(" "),s("h2",{attrs:{id:"列举你所了解的编程范式？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列举你所了解的编程范式？"}},[a._v("#")]),a._v(" 列举你所了解的编程范式？")]),a._v(" "),s("h2",{attrs:{id:"什么是面向切面（aop）的编程？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是面向切面（aop）的编程？"}},[a._v("#")]),a._v(" 什么是面向切面（AOP）的编程？")]),a._v(" "),s("h2",{attrs:{id:"什么是函数式编程？什么是响应式编程？什么是函数响应式编程？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是函数式编程？什么是响应式编程？什么是函数响应式编程？"}},[a._v("#")]),a._v(" 什么是函数式编程？什么是响应式编程？什么是函数响应式编程？")]),a._v(" "),s("h2",{attrs:{id:"响应式编程或者函数响应式编程的使用场景有哪些？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应式编程或者函数响应式编程的使用场景有哪些？"}},[a._v("#")]),a._v(" 响应式编程或者函数响应式编程的使用场景有哪些？")])])}),[],!1,null,null,null);t.default=e.exports}}]);